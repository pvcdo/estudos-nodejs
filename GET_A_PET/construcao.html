<h1>Criação do sistema</h1>

<h2>Configuração geral</h2>
<p>get-a-pet -> pastas (server; client)</p>

<h2>Server (side) / Back-end </h2>

<h3>Início</h3>
<p>pasta server (server) -> npm i bcrypt cookie-parser cors express jsonwebtoken mongoose multer nodemon
    <ul>
        <li>bcrypt = criptografia de senhas</li>
        <li>cookie-parser = </li>
        <li>cors = para podermos mandar requisições para o nosso mesmo domínio. Quando lidamos com front e back há conflitos que este módulo trata</li>
        <li>jsonwebtoken = autenticação de usuários</li>
        <li>multer = upload de fotos (singular e multiplos)</li>
    </ul>
</p>
<p>server -> pastas mvc (menos a de views), db, helpers (funções auxiliares para serem acessadas em várias rotas), public, public/img/users, public/img/pets, routes</p>
<p>index = const express ; const cors ; const app ; app.use(express.json()) ; app.use(cors({credentials: true, origin: 'http://localhost:3000'})) ; app.use(express.static('public')) ; app.listen(5000)
    <ul>
        <li>Não precisaremos de express.urlencoded porque a comunicação será toda por json</li>
        <li>em cors, o origin é o ip do front-end. Como o front e o back estão em localhost o navegador acusaria um erro, que é solucionado com esse middleware</li>
    </ul>
</p>
<p>package.json -> script start nodemon</p>

<h3>Criando models</h3>

<p>db/conn.js = { const mongoose ; mongoose.connect(uri) then {console ; module.exports = mongoose} }</p>
<p>models/User.js = { const mongoose ; const {Schema} = mongoose ; const User = mongoose.model('nome banco', new Schema({atributos}, {timestamps: true})) ; module.exports = User}
    <ul>
        <li>o timestamps vai criar os campos createdAt e updatedAt, registrando quando o dado foi criado e atualizado, respectivamente</li>
    </ul>
</p>
<p>models/Pet.js = { const mongoose ; const {Schema} = mongoose ; const User = mongoose.model('nome banco', new Schema({atributos}, {timestamps: true})) ; module.exports = User}</p>

<h3>Criando rotas de usuários</h3>

<p>routes/UserRoutes.js (ur)</p>
<p>controllers/UserController.js (uc)</p>
<p>index -> app.use('/users',require('./routes/UserRoutes'))</p>
<p>UserRoutes = { const router ; router.post('/register', uc.register) ; module.exports = router }</p>
<p>uc = { const User = require(model) ; exports = class UserController { static async register { res.json 'Estamos registrando um usuário' } } }</p>
<p>no postman criar a collection pro projeto, dentro dessa collection outras duas, uma para Users e outra para Pets</p>
<p>criar a variável url com o valor http://localhost:5000</p>
<p>testar a rota register de user no postman</p>

<h3>Validação de usuários</h3>

<p>uc.register -> receber os atributos de usuário a partir de req.body ; validar se: 
    <ul>
        <li>todos atributos vieram</li>
        <li>senha e confirmação de senha iguais</li>
        <li>usuário já existe no banco de dados (User.findOne({email})</li>
    </ul>
</p>
<p>todas falhas de verificação retornam um status de 422</p>

<h3>Registrando usuário no banco</h3>

<p>uc -> import bcrypt</p>
<p>uc.register -> {... ; salt ; passwordHash ; user = new User({atributos {... , password: passwordHash}}) ; try new_user = await user.save();  res.status(201).json({message, new_user}), catch(e) status(500).json({message})} </p>

<h3>Retornando o token JWT (json web token)</h3>

<p>criar helpers/create-user-token.js = { require(jsonwebtoken) ; function createUserToken(user,req,res){const token = jwt.sign({name:user.name,id:user._id},"nossosecret") ; res.status(200).json({message,token,userId:user._id})} ; module.exports = createUserToken }</p>

<p>uc -> require create-user-token</p>

<p>uc.register -> apagar try catch final e dar um createUserToken passando o usuário registrado, req e res</p>

<h3>Função de login no sistema</h3>

<p>ur -> post('/login', uc.login)</p>

<p>uc ->  async login { const email, password = req.body ; validações email e senha ; checar User.findOne({email}) ; checar bcrypt.compare(senha_front, user.password) /*o primeiro atributo é a senha que foi fornecida no formulário de login, o segundo a senha que está no banco de dados para aquele usuário*/ ; await createUserToken(user) }</p>

<h3>Verificando usuário pelo token</h3>

<p>uc -> async checkUser { let currentUser ; console.log(req.headers.authorization) ;/*as: auth*/ if(req.headers.authorization){}else{currentUser = null} ; req.status(200).send(currentUser) ; } </p>

<p>ur -> get('checkUser', uc.checkUser)</p>

<p>postman -> get {{url}}/users/checkUser ; get-a-pet => variables => TOKEN => token de post users/login ; get checkUser => authorization => type = bearer token = {{TOKEN}} /*ao enviar deve aparecer o token no cmd*/ </p>

<p>helpers/get-token.js -> { const getToken(req){ const authHeader = req.headers.authorization ; const token = authHeader.split 1 ; return token } ; module.exports = getToken } </p>

<p>uc -> import helpers/get-token ; import jwt</p>

<p>uc.checkUser -> auth: {const = getToken(req) ; const decoded = jwt.verify(token,'nossosecret') ; currentUser = await User.findById(decoded.id) ; currentUser.password = undefined }</p>

<h3>Pegar usuário pelo id</h3>

<p>ur -> get('/:id',uc.getUserById)</p>

<p>uc -> async getUserById { const id = req.params ; const user = await User.findById(id).select("-password") ; if(!user){res.status(422).json("nao encontrado") return } ; res.status(200).json(user)  } 
    <ul>
        <li>o método select usado no findById indica que vamos excluir o campo password do retorno do método findById</li>
        <li>outra forma já abordada de não termos o password exposto é atribuirmos undefined à user.password</li>
    </ul>
</p>

<h3>Verificação do token do usuário</h3>

<p>ur -> patch('/update/:id',uc.updateUser)
    <ul>
        <li>patch é um método http usado para atualizar dados</li>
    </ul>
</p>

<p>Vamos criar uma função helper para verificar o token do usuário, caso exista um token e este seja válido o usuário poderá entrar na rota de update</p>

<p>//verify-token.js
    const jwt = require("jsonwebtoken");
    const getToken = require("./get-token")

    // middleware to validate token
    const checkToken = (req, res, next) => {
        if(!req.headers.authorization){
            return res.status(401).json({ message: "Acesso negado!" });
        } 

        const token = getToken(req)
        if(!token){
            return res.status(401).json({ message: "Acesso negado!" });
        }

        try {
            const verified = jwt.verify(token, "nossosecret");
            req.user = verified;
            next(); // to continue the flow
        } catch (err) {
            res.status(400).json({ message: "O Token é inválido!" });
        }
    };

    module.exports = checkToken;
</p>

<p>ur -> import verify-token</p>

<p>ur -> .patch('/update/:id',verify-token, ... ) </p>

<p>uc -> async updateUser(r,r){ res.status(200).json("deu certo") }</p>

<h3>Atualizações usuário</h3>

<p>// helpers/get-user-by-token.js
    const jwt = require("jsonwebtoken");
    const User = require("../models/User")

    const getUserByToken = async (token) => {
        if(!token){
            return res.status(401).json({ message: "Acesso negado!" });
        } 

        const verified = jwt.verify(token,"nossosecret")
        const _id = verified.id
        const user = await User.findOne({_id})
        return user
    };

    module.exports = getUserByToken;
</p>

<p>uc -> import get-user-by-token</p>

<p>uc.updateUser = { const id = params ; const user = await get-user-by-token(get-token(req)) ; const {name,email,phone,password,confirm_password} = body ; let image = "" ; validações de name, email e phone dos const.body ; após cada validação o valor do atributo do usuário será atualizado para o valor enviado pelo body } </p>

<p>postman</p>

<p>uc.updateUser = { ... ; validação de password e confirm ; try{ await User.findOneAndUpdate({_id:id}, {$set:user}, {new:true}) }catch(e){res de erro} } 
    <ul>
        <li>no objeto $set:user eu entendo que serão atualizados todos os atributos do documento encontrado pelo filtro que foi passado como primeiro parâmetro do método findOneAndUpdate</li>
    </ul>
</p>

<p>postman tentando dar login com dados velhos e novos</p>

<h3>Upload de imagem</h3>

<p>// helper/image-upload.js
    const multer = require("multer");
    const path = require("path");

    // Destination to store image
    const imageStorage = multer.diskStorage({
    destination: function (req, file, cb) {
        let folder = "";

        console.log(req)

        if (req.baseUrl.includes('users')) {
        folder = "users";
        } else if (req.baseUrl.includes('pets')) {
        folder = "pets";
        }
        cb(null, `public/img/${folder}/`);
    },
    filename: (req, file, cb) => {
        cb(null, Date.now() + path.extname(file.originalname));
    },
    });

    const imageUpload = multer({
    storage: imageStorage,
    fileFilter(req, file, cb) {
        if (!file.originalname.match(/\.(png|jpg)$/)) {
        // upload only png and jpg format
        return cb(new Error("Por favor, envie apenas png ou jpg!"));
        }
        cb(undefined, true);
    },
    });

    module.exports = { imageUpload };
    <ul>
        <li>usou regex para validar se a imagem enviada era jpg ou png</li>
    </ul>
</p>

<p>ur -> const {imgUpload} = require image-upload</p>

<p>ur.patch('/update/:id',...,imgUpload.single('image'),...}
    <ul>
        <li>o método single é usado para imagens únicas, ainda utilizaremos envio de várias imagens para os pets através do multer</li>
        <li>no caso o middleware imgUpload vai ver se foi recebido pelo formulário</li>
    </ul>
</p>

<p>uc.updateUser -> { ... ; apagar let image ; if(req.file){user.image = req.file.filename} }</p>

<p>postman.updateUser = alterar envio do body de raw para form-data ; alterar o tipo da key image para file (diferente de text que é o padrão)</p>

<h3>Iniciando rota de pets</h3>

<p>routes/PetRoutes.js (pr)</p>

<p>pr -> const PetController</p>

<p>pr -> post('create',pc.create)</p>

<p>PetController (pc)</p>

<p>pc -> const User ; const Pet</p>

<p>pc.create(r,r)=>{res.json sucesso}</p>

<p>index -> const PetRoutes ; app.use('/pets',pr)</p>

<p>postman/pets -> post /pets/create</p>

<h3>Salvando pets no sistema</h3>

<p>pr -> const verifyToken
    <ul><li>não queremos que alguem não autenticado salve um pet</li></ul>
</p>

<p>pr -> post('create',verifyToken,...)</p>

<p>postman -> testar post create sem e com token em authorization</p>

<p>pc.create -> const name, age, weight, color = req.body ; const avaiable = true ; validações dos req.body</p>

<p>postman.post(create) -> body-raw-completar o body</p>

<p>pc -> //helpers = { const getToken ; const getUserByToken }</p>

<p>pc.create -> //get pet owner = { const token = await getToken(req) ; const user = await getUserByToken(token) }  ; //create a pet = { const pet = new Pet({atributos + user}) } ; try{ const newPet = await pet.save() ; json {sucesso ; newPet} }catch(e){json erro}</p>

<h3>Upload de múltiplas imagens</h3>

<p>pr -> const {imgUpload} = require(helpers/image-upload)</p>

<p>pr -> post('create',...,imgUpload.array('images'),...)  </p>

<p>pc.create -> { const images = req.files ; verificar se images veio na requisição ; //depois de new Pet = { images.forEach((image) => { pet.images.push(image.filename) }) } } </p>

<p>helpers/image-upload -> incrementar o nome da imagem, uma vez que as imagens são upadas muito rapidamente e o nome é baseado no horário de envio (ele usou Math.random para solucionar isso e eu adicionei os 5 primeiros caracteres do token do usuário)</p>

<p>postman -> post.create = body-form_data</p>

<h3>Função de resgatar todos os Pets</h3>

<p>pr -> get('/',pc.getAll ) </p>

<p>pc.getAll(r,r){ const pets = await Pet.find().sort('-createdAt') //nesse caso ele vai ordenar do mais último cadastrado ao primeiro (Z à A) ; json{sucesso, pets} }</p>

<p> postman -> get./pets/ </p>

<h3>Resgatar todos os pets do usuário logado</h3>

<p>pr -> get('/mypets', verifyToken, pc.getAllUserPets) </p>

<p> pc.getAllUserPets(r,r){ const token ; const user = getUserByToken ; const pets = Pet.find({'user_id':user_id}).sort('-createdAt') ; json({msg: sucesso, pets}) } </p>

<p>postman</p>

<h3>Resgatar todos os pets com processo de adoção pelo usuário</h3>

<p>pr -> get('/myadoptions',verifyToken,pc.getAllUserAdoptions)</p>

<p>pc.getAllUserAdoptions(rr){ token ; user(token) ; const pets = await Pet.find("adopter._id":user._id).sort() }</p>

<p>postman</p>

<h3>Resgatar pet pelo id</h3>

<p>pr -> get('/:id',pc.getPetById)</p>

<p>pc -> //helpers = { const ObjectId = require('mongoose').Types.ObjectId }
    <ul>
        <li>é o tipo ObjectId do mongoose, que dá a possibilidade de verificarmos se um id é válido para a estrutura do mongoDB</li>
    </ul>
</p>

<p>pc ->getPetById(rr){ const id = req.params ; if(!ObjectId.isValid(id)){status422.json erro} ; const pet = await Pet.findOne({_id:id}) ; if(!pet){ status404.json erro } ; status.json sucesso+pet } </p>

<p>postman</p>

<h3>Deletar um pet</h3>

<p>pr -> delete('/:id',verifyToken,pc.deletePet)</p>

<p>pc ->deletePet(rr){ const id = req.params ; if(!ObjectId.isValid(id)){status422.json erro} ; const pet = await Pet.findOne({_id:id}) ; if(!pet){ status404.json erro } ; token ; const user = getUserByToken ; if(pet.owner._id.toString() !== user._id.toString()){ status.json erro } ; await Pet.findByIdAndRemove(id) ; status200.json sucesso } </p>

<p>postman</p>

<h3>Atualização do pet</h3>

<p>pr -> patch('/:id',verifyToken,imageUpload.array('images'),pc.updatePet)</p>

<p>pc -> updatePet(rr){ const id ; const {atributos do pet} = req.body ; const images = req.files ; const updateData = {} ; pegar o pet e checar se o pet existe ; checar se o pet é do usuário logado ; verificar cada campo que vem do body, caso passe ele entra em updateData ; a verificação do images é se o array tem tamanho diferente de 0, sendo maior que 0 { updateData.images = [] ; images.forEach((image) => { updateData.images.push(image.filename) }) } ; await Pet.findByIdAndUpdate(id,updateData) ; status.json sucesso } </p>

<p>postman</p>

<h3>Agendando visita de adoção</h3>

<p>pr -> patch('/schedule/:id',verifyToken,PetController.schedule) </p>

<p>pr -> schedule(rr){ pegar o pet pelo id e checar se vem algum pet ; verificar se o pet é do usuário logado, se sim está errado (usado o método equals para verificar os ids) ; if(pet.adopter){ if(pet.adopter._id.equals(user._id){ status422.json({o usuário já agendou}) } ) } ; pet.adopter = {_id:user._id,name:user.name,image:user.image} ; await Pet.findByIdAndUpdate(id,pet) ; status200.json({sucesso, entre em contato}) }</p>

<h3>Concluindo a adoção do pet</h3>

<p>pr -> patch('/conlude/:id',verifyToken,pc.concludeAdoption)</p>

<p>pc.concludeAdoption(rr){ const id ; verificar id ; const pet ; verificar pet ; const user ; verificar se o pet é do usuário, apenas o dono do pet pode executar esse método ; pet.available = false ; await Pet.findByIdAndUpdate(id,pet) ; status200.json({sucesso}) }</p>

<h2>Client (side) / Front-end </h2>

<h3>Início</h3>

<p>na pasta ./client rodamos <code style="color: red ;">npx create-react-app .</code></p>

<p>Depois do react instalado damos o npm start.</p>

<p>instalamos os pacotes: 
    <ul>
        <li>axios: conexão com a api</li>
        <li>events: enviar mensageria entre componentes</li>
        <li>react-icons</li>
        <li>react-router-dom: roteamento de páginas, permite criar páginas de uma forma simples</li>
    </ul>
</p>

<p>na pasta client criamos o arquivo ".env.local" para criar como se fosse uma variável de ambiente para armazenar o endereço da api. Neste arquivo escrevemos " REACT_APP_API = 'http://localhost:5000/' "</p>

<h3>Estruturando o projeto</h3>

<p>em public tirou tudo, menos o index.html</p>

<p>ainda em public colocou o icon de cachorrinho</p>

<p>em src deixou apenas App.js (app), index.css e index.js</p>

<p>em public/index.html alterou o title</p>

<p>em app.js tirou os imports e no retorno da função App dentro de div.App ele colocou um h1 com o título</p>

<p>em index.js ele tirou o reportWebVitals de todos os lugares</p>

<p>criamos em src as pastas 
    <ul>
        <li>assets: pasta para arquivos estáticos</li>
        <li>assets/img: colocar nele a imagem de logo</li>
        <li>components: partes reutilizáveis do sistema</li>
        <li>context: substitui ou evita o uso do redux, tendo o objetivo de gerar como se fossem pacotes de estilizações de acordo com a situação apresentada no momento do aplicação</li>
        <li>hooks: criar "porções de código"</li>
        <li>utils: igual ao helpers do server</li>
    </ul> 
</p>

<!-- PRATICAR A PARTIR DAQUI -->
<!-- *************************************************************** -->

<h3>Inserindo o react-router</h3>

<p>atualizar *, h1 e .bold em index.css</p>

<p>em App.js ele fez

    <pre>
        import {
            BrowserRouter as Router,
            Routes,
            Route,
            Navigate,
          } from 'react-router-dom'
          
          function App() {
            return (
              Router>
                Routes>
                  Route path="/" />
                  Route path="/register" />
                  Route path="/login" />
                /Routes>
              /Router>
            )
          }
          
          export default App
    </pre>
</p>

<p>criou components/pages/Home.js (home)</p>

<p>home -> { Home(){return( section{h1=Home} )} ; export default Home } </p>

<p>criou components/pages/Auth/Login.js (login) e Register.js (register), baseados em home, alterando apenas estes termos principais por seus respectivos</p>

<p>em App.js ele importou as páginas criadas e em cada Route ele colocou o atributo element que recebe um objeto que encapsula a página respectiva importada. Nesse objeto o nome da página deve estar na notação de uma tag html.</p>

<h3>Estruturando Navbar e footer</h3>

<p>A partir de agora subentenderemos que, à priori, os códigos estarão dentro do return da função principal e a função principal será exportada a partir de export default, salvo disposições diversas. Importações serão feitas antes da declaração da função principal.</p>

<p>criou components/layouts/Footer.js (footer) e Navbar.js (navbar) baseados em home</p>

<p>Em App.js (app) importamos footer e navbar, sendo que Navbar fica antes dentro de Router, antes de Routes; Footer fica depois de Routes</p>

<p>em navbar importou {Link} de react-router-dom e Logo de assets/img e codou a estrutura nav{div{img;h2} ; ul{li{Link}} } ; em Link colocou o atributo "to" que recebe a rota que será colocada na url e no innerHTML de Link o texto a ser exibido no link
    <ul>
        <li>A estrutura de img é src={"caminho/da/imagem"} e alt="texto alternativo"</li>
    </ul>
</p>

<p>em footer vamos colocar a estrutura footer>p>span </p>

