<h1>Criação do sistema</h1>

<h2>Configuração geral</h2>
<p>get-a-pet -> pastas (server; client)</p>

<h2>Server (side) / Back-end </h2>

<h3>Início</h3>
<p>pasta server (server) -> npm i bcrypt cookie-parser cors express jsonwebtoken mongoose multer nodemon
<ul>
  <li>bcrypt = criptografia de senhas</li>
  <li>cookie-parser = </li>
  <li>cors = para podermos mandar requisições para o nosso mesmo domínio. Quando lidamos com front e back há conflitos
    que este módulo trata</li>
  <li>jsonwebtoken = autenticação de usuários</li>
  <li>multer = upload de fotos (singular e multiplos)</li>
</ul>
</p>
<p>server -> pastas mvc (menos a de views), db, helpers (funções auxiliares para serem acessadas em várias rotas),
  public, public/img/users, public/img/pets, routes</p>
<p>index = const express ; const cors ; const app ; app.use(express.json()) ; app.use(cors({credentials: true, origin:
  'http://localhost:3000'})) ; app.use(express.static('public')) ; app.listen(5000)
<ul>
  <li>Não precisaremos de express.urlencoded porque a comunicação será toda por json</li>
  <li>em cors, o origin é o ip do front-end. Como o front e o back estão em localhost o navegador acusaria um erro, que
    é solucionado com esse middleware</li>
</ul>
</p>
<p>package.json -> script start nodemon</p>

<h3>Criando models</h3>

<p>db/conn.js = { const mongoose ; mongoose.connect(uri) then {console ; module.exports = mongoose} }</p>
<p>models/User.js = { const mongoose ; const {Schema} = mongoose ; const User = mongoose.model('nome banco', new
  Schema({atributos}, {timestamps: true})) ; module.exports = User}
<ul>
  <li>o timestamps vai criar os campos createdAt e updatedAt, registrando quando o dado foi criado e atualizado,
    respectivamente</li>
</ul>
</p>
<p>models/Pet.js = { const mongoose ; const {Schema} = mongoose ; const User = mongoose.model('nome banco', new
  Schema({atributos}, {timestamps: true})) ; module.exports = User}</p>

<h3>Criando rotas de usuários</h3>

<p>routes/UserRoutes.js (ur)</p>
<p>controllers/UserController.js (uc)</p>
<p>index -> app.use('/users',require('./routes/UserRoutes'))</p>
<p>UserRoutes = { const router ; router.post('/register', uc.register) ; module.exports = router }</p>
<p>uc = { const User = require(model) ; exports = class UserController { static async register { res.json 'Estamos
  registrando um usuário' } } }</p>
<p>no postman criar a collection pro projeto, dentro dessa collection outras duas, uma para Users e outra para Pets</p>
<p>criar a variável url com o valor http://localhost:5000</p>
<p>testar a rota register de user no postman</p>

<h3>Validação de usuários</h3>

<p>uc.register -> receber os atributos de usuário a partir de req.body ; validar se:
<ul>
  <li>todos atributos vieram</li>
  <li>senha e confirmação de senha iguais</li>
  <li>usuário já existe no banco de dados (User.findOne({email})</li>
</ul>
</p>
<p>todas falhas de verificação retornam um status de 422</p>

<h3>Registrando usuário no banco</h3>

<p>uc -> import bcrypt</p>
<p>uc.register -> {... ; salt ; passwordHash ; user = new User({atributos {... , password: passwordHash}}) ; try
  new_user = await user.save(); res.status(201).json({message, new_user}), catch(e) status(500).json({message})} </p>

<h3>Retornando o token JWT (json web token)</h3>

<p>criar helpers/create-user-token.js = { require(jsonwebtoken) ; function createUserToken(user,req,res){const token =
  jwt.sign({name:user.name,id:user._id},"nossosecret") ; res.status(200).json({message,token,userId:user._id})} ;
  module.exports = createUserToken }</p>

<p>uc -> require create-user-token</p>

<p>uc.register -> apagar try catch final e dar um createUserToken passando o usuário registrado, req e res</p>

<h3>Função de login no sistema</h3>

<p>ur -> post('/login', uc.login)</p>

<p>uc -> async login { const email, password = req.body ; validações email e senha ; checar User.findOne({email}) ;
  checar bcrypt.compare(senha_front, user.password) /*o primeiro atributo é a senha que foi fornecida no formulário de
  login, o segundo a senha que está no banco de dados para aquele usuário*/ ; await createUserToken(user) }</p>

<h3>Verificando usuário pelo token</h3>

<p>uc -> async checkUser { let currentUser ; console.log(req.headers.authorization) ;/*as: auth*/
  if(req.headers.authorization){}else{currentUser = null} ; req.status(200).send(currentUser) ; } </p>

<p>ur -> get('checkUser', uc.checkUser)</p>

<p>postman -> get {{url}}/users/checkUser ; get-a-pet => variables => TOKEN => token de post users/login ; get checkUser
  => authorization => type = bearer token = {{TOKEN}} /*ao enviar deve aparecer o token no cmd*/ </p>

<p>helpers/get-token.js -> { const getToken(req){ const authHeader = req.headers.authorization ; const token =
  authHeader.split 1 ; return token } ; module.exports = getToken } </p>

<p>uc -> import helpers/get-token ; import jwt</p>

<p>uc.checkUser -> auth: {const = getToken(req) ; const decoded = jwt.verify(token,'nossosecret') ; currentUser = await
  User.findById(decoded.id) ; currentUser.password = undefined }</p>

<h3>Pegar usuário pelo id</h3>

<p>ur -> get('/:id',uc.getUserById)</p>

<p>uc -> async getUserById { const id = req.params ; const user = await User.findById(id).select("-password") ;
  if(!user){res.status(422).json("nao encontrado") return } ; res.status(200).json(user) }
<ul>
  <li>o método select usado no findById indica que vamos excluir o campo password do retorno do método findById</li>
  <li>outra forma já abordada de não termos o password exposto é atribuirmos undefined à user.password</li>
</ul>
</p>

<h3>Verificação do token do usuário</h3>

<p>ur -> patch('/update/:id',uc.updateUser)
<ul>
  <li>patch é um método http usado para atualizar dados</li>
</ul>
</p>

<p>Vamos criar uma função helper para verificar o token do usuário, caso exista um token e este seja válido o usuário
  poderá entrar na rota de update</p>

<p>//verify-token.js
  const jwt = require("jsonwebtoken");
  const getToken = require("./get-token")

  // middleware to validate token
  const checkToken = (req, res, next) => {
  if(!req.headers.authorization){
  return res.status(401).json({ message: "Acesso negado!" });
  }

  const token = getToken(req)
  if(!token){
  return res.status(401).json({ message: "Acesso negado!" });
  }

  try {
  const verified = jwt.verify(token, "nossosecret");
  req.user = verified;
  next(); // to continue the flow
  } catch (err) {
  res.status(400).json({ message: "O Token é inválido!" });
  }
  };

  module.exports = checkToken;
</p>

<p>ur -> import verify-token</p>

<p>ur -> .patch('/update/:id',verify-token, ... ) </p>

<p>uc -> async updateUser(r,r){ res.status(200).json("deu certo") }</p>

<h3>Atualizações usuário</h3>

<p>// helpers/get-user-by-token.js
  const jwt = require("jsonwebtoken");
  const User = require("../models/User")

  const getUserByToken = async (token) => {
  if(!token){
  return res.status(401).json({ message: "Acesso negado!" });
  }

  const verified = jwt.verify(token,"nossosecret")
  const _id = verified.id
  const user = await User.findOne({_id})
  return user
  };

  module.exports = getUserByToken;
</p>

<p>uc -> import get-user-by-token</p>

<p>uc.updateUser = { const id = params ; const user = await get-user-by-token(get-token(req)) ; const
  {name,email,phone,password,confirm_password} = body ; let image = "" ; validações de name, email e phone dos
  const.body ; após cada validação o valor do atributo do usuário será atualizado para o valor enviado pelo body } </p>

<p>postman</p>

<p>uc.updateUser = { ... ; validação de password e confirm ; try{ await User.findOneAndUpdate({_id:id}, {$set:user},
  {new:true}) }catch(e){res de erro} }
<ul>
  <li>no objeto $set:user eu entendo que serão atualizados todos os atributos do documento encontrado pelo filtro que
    foi passado como primeiro parâmetro do método findOneAndUpdate</li>
</ul>
</p>

<p>postman tentando dar login com dados velhos e novos</p>

<h3>Upload de imagem</h3>

<p>// helper/image-upload.js
  const multer = require("multer");
  const path = require("path");

  // Destination to store image
  const imageStorage = multer.diskStorage({
  destination: function (req, file, cb) {
  let folder = "";

  console.log(req)

  if (req.baseUrl.includes('users')) {
  folder = "users";
  } else if (req.baseUrl.includes('pets')) {
  folder = "pets";
  }
  cb(null, `public/img/${folder}/`);
  },
  filename: (req, file, cb) => {
  cb(null, Date.now() + path.extname(file.originalname));
  },
  });

  const imageUpload = multer({
  storage: imageStorage,
  fileFilter(req, file, cb) {
  if (!file.originalname.match(/\.(png|jpg)$/)) {
  // upload only png and jpg format
  return cb(new Error("Por favor, envie apenas png ou jpg!"));
  }
  cb(undefined, true);
  },
  });

  module.exports = { imageUpload };
<ul>
  <li>usou regex para validar se a imagem enviada era jpg ou png</li>
</ul>
</p>

<p>ur -> const {imgUpload} = require image-upload</p>

<p>ur.patch('/update/:id',...,imgUpload.single('image'),...}
<ul>
  <li>o método single é usado para imagens únicas, ainda utilizaremos envio de várias imagens para os pets através do
    multer</li>
  <li>no caso o middleware imgUpload vai ver se foi recebido pelo formulário</li>
</ul>
</p>

<p>uc.updateUser -> { ... ; apagar let image ; if(req.file){user.image = req.file.filename} }</p>

<p>postman.updateUser = alterar envio do body de raw para form-data ; alterar o tipo da key image para file (diferente
  de text que é o padrão)</p>

<h3>Iniciando rota de pets</h3>

<p>routes/PetRoutes.js (pr)</p>

<p>pr -> const PetController</p>

<p>pr -> post('create',pc.create)</p>

<p>PetController (pc)</p>

<p>pc -> const User ; const Pet</p>

<p>pc.create(r,r)=>{res.json sucesso}</p>

<p>index -> const PetRoutes ; app.use('/pets',pr)</p>

<p>postman/pets -> post /pets/create</p>

<h3>Salvando pets no sistema</h3>

<p>pr -> const verifyToken
<ul>
  <li>não queremos que alguem não autenticado salve um pet</li>
</ul>
</p>

<p>pr -> post('create',verifyToken,...)</p>

<p>postman -> testar post create sem e com token em authorization</p>

<p>pc.create -> const name, age, weight, color = req.body ; const avaiable = true ; validações dos req.body</p>

<p>postman.post(create) -> body-raw-completar o body</p>

<p>pc -> //helpers = { const getToken ; const getUserByToken }</p>

<p>pc.create -> //get pet owner = { const token = await getToken(req) ; const user = await getUserByToken(token) } ;
  //create a pet = { const pet = new Pet({atributos + user}) } ; try{ const newPet = await pet.save() ; json {sucesso ;
  newPet} }catch(e){json erro}</p>

<h3>Upload de múltiplas imagens</h3>

<p>pr -> const {imgUpload} = require(helpers/image-upload)</p>

<p>pr -> post('create',...,imgUpload.array('images'),...) </p>

<p>pc.create -> { const images = req.files ; verificar se images veio na requisição ; //depois de new Pet = {
  images.forEach((image) => { pet.images.push(image.filename) }) } } </p>

<p>helpers/image-upload -> incrementar o nome da imagem, uma vez que as imagens são upadas muito rapidamente e o nome é
  baseado no horário de envio (ele usou Math.random para solucionar isso e eu adicionei os 5 primeiros caracteres do
  token do usuário)</p>

<p>postman -> post.create = body-form_data</p>

<h3>Função de resgatar todos os Pets</h3>

<p>pr -> get('/',pc.getAll ) </p>

<p>pc.getAll(r,r){ const pets = await Pet.find().sort('-createdAt') //nesse caso ele vai ordenar do mais último
  cadastrado ao primeiro (Z à A) ; json{sucesso, pets} }</p>

<p> postman -> get./pets/ </p>

<h3>Resgatar todos os pets do usuário logado</h3>

<p>pr -> get('/mypets', verifyToken, pc.getAllUserPets) </p>

<p> pc.getAllUserPets(r,r){ const token ; const user = getUserByToken ; const pets =
  Pet.find({'user_id':user_id}).sort('-createdAt') ; json({msg: sucesso, pets}) } </p>

<p>postman</p>

<h3>Resgatar todos os pets com processo de adoção pelo usuário</h3>

<p>pr -> get('/myadoptions',verifyToken,pc.getAllUserAdoptions)</p>

<p>pc.getAllUserAdoptions(rr){ token ; user(token) ; const pets = await Pet.find("adopter._id":user._id).sort() }</p>

<p>postman</p>

<h3>Resgatar pet pelo id</h3>

<p>pr -> get('/:id',pc.getPetById)</p>

<p>pc -> //helpers = { const ObjectId = require('mongoose').Types.ObjectId }
<ul>
  <li>é o tipo ObjectId do mongoose, que dá a possibilidade de verificarmos se um id é válido para a estrutura do
    mongoDB</li>
</ul>
</p>

<p>pc ->getPetById(rr){ const id = req.params ; if(!ObjectId.isValid(id)){status422.json erro} ; const pet = await
  Pet.findOne({_id:id}) ; if(!pet){ status404.json erro } ; status.json sucesso+pet } </p>

<p>postman</p>

<h3>Deletar um pet</h3>

<p>pr -> delete('/:id',verifyToken,pc.deletePet)</p>

<p>pc ->deletePet(rr){ const id = req.params ; if(!ObjectId.isValid(id)){status422.json erro} ; const pet = await
  Pet.findOne({_id:id}) ; if(!pet){ status404.json erro } ; token ; const user = getUserByToken ;
  if(pet.owner._id.toString() !== user._id.toString()){ status.json erro } ; await Pet.findByIdAndRemove(id) ;
  status200.json sucesso } </p>

<p>postman</p>

<h3>Atualização do pet</h3>

<p>pr -> patch('/:id',verifyToken,imageUpload.array('images'),pc.updatePet)</p>

<p>pc -> updatePet(rr){ const id ; const {atributos do pet} = req.body ; const images = req.files ; const updateData =
  {} ; pegar o pet e checar se o pet existe ; checar se o pet é do usuário logado ; verificar cada campo que vem do
  body, caso passe ele entra em updateData ; a verificação do images é se o array tem tamanho diferente de 0, sendo
  maior que 0 { updateData.images = [] ; images.forEach((image) => { updateData.images.push(image.filename) }) } ; await
  Pet.findByIdAndUpdate(id,updateData) ; status.json sucesso } </p>

<p>postman</p>

<h3>Agendando visita de adoção</h3>

<p>pr -> patch('/schedule/:id',verifyToken,PetController.schedule) </p>

<p>pr -> schedule(rr){ pegar o pet pelo id e checar se vem algum pet ; verificar se o pet é do usuário logado, se sim
  está errado (usado o método equals para verificar os ids) ; if(pet.adopter){ if(pet.adopter._id.equals(user._id){
  status422.json({o usuário já agendou}) } ) } ; pet.adopter = {_id:user._id,name:user.name,image:user.image} ; await
  Pet.findByIdAndUpdate(id,pet) ; status200.json({sucesso, entre em contato}) }</p>

<h3>Concluindo a adoção do pet</h3>

<p>pr -> patch('/conlude/:id',verifyToken,pc.concludeAdoption)</p>

<p>pc.concludeAdoption(rr){ const id ; verificar id ; const pet ; verificar pet ; const user ; verificar se o pet é do
  usuário, apenas o dono do pet pode executar esse método ; pet.available = false ; await Pet.findByIdAndUpdate(id,pet)
  ; status200.json({sucesso}) }</p>

<h2>Client (side) / Front-end </h2>

<h3>Início</h3>

<p>na pasta ./client rodamos <code style="color: red ;">npx create-react-app .</code></p>

<p>Depois do react instalado damos o npm start.</p>

<p>instalamos os pacotes:
<ul>
  <li>axios: conexão com a api</li>
  <li>events: enviar mensageria entre componentes</li>
  <li>react-icons</li>
  <li>react-router-dom: roteamento de páginas, permite criar páginas de uma forma simples</li>
</ul>
</p>

<p>na pasta client criamos o arquivo ".env.local" para criar como se fosse uma variável de ambiente para armazenar o
  endereço da api. Neste arquivo escrevemos " REACT_APP_API = 'http://localhost:5000/' "</p>

<h3>Estruturando o projeto</h3>

<p>em public tirou tudo, menos o index.html</p>

<p>ainda em public colocou o icon de cachorrinho</p>

<p>em src deixou apenas App.js (app), index.css e index.js</p>

<p>em public/index.html alterou o title</p>

<p>em app.js tirou os imports e no retorno da função App dentro de div.App ele colocou um h1 com o título</p>

<p>em index.js ele tirou o reportWebVitals de todos os lugares</p>

<p>criamos em src as pastas
<ul>
  <li>assets: pasta para arquivos estáticos</li>
  <li>assets/img: colocar nele a imagem de logo</li>
  <li>components: partes reutilizáveis do sistema</li>
  <li>context: substitui ou evita o uso do redux, tendo o objetivo de gerar como se fossem pacotes de estilizações de
    acordo com a situação apresentada no momento do aplicação</li>
  <li>hooks: criar "porções de código"</li>
  <li>utils: igual ao helpers do server</li>
</ul>
</p>

<h3>Inserindo o react-router</h3>

<p>atualizar *, h1 e .bold em index.css</p>

<p>em App.js ele fez

<pre>
        import {
            BrowserRouter as Router,
            Routes,
            Route,
            Navigate,
          } from 'react-router-dom'
          
          function App() {
            return (
              Router>
                Routes>
                  Route path="/" />
                  Route path="/register" />
                  Route path="/login" />
                /Routes>
              /Router>
            )
          }
          
          export default App
    </pre>
</p>

<p>criou components/pages/Home.js (home)</p>

<p>home -> { Home(){return( section{h1=Home} )} ; export default Home } </p>

<p>criou components/pages/Auth/Login.js (login) e Register.js (register), baseados em home, alterando apenas estes
  termos principais por seus respectivos</p>

<p>em App.js ele importou as páginas criadas e em cada Route ele colocou o atributo element que recebe um objeto que
  encapsula a página respectiva importada. Nesse objeto o nome da página deve estar na notação de uma tag html.</p>

<h3>Estruturando Navbar e footer</h3>

<p>A partir de agora subentenderemos que, à priori, os códigos estarão dentro do return da função principal e a função principal será exportada a partir de export default, salvo disposições diversas. Importações serão feitas antes da declaração da função principal. Também entenderemos que todas as criações de página seguirão o padrão a seguir:</p>

<pre>
  function Nome(){
    return(
      section>
        h1>Nome /h1>
      /section>
    )
  }
  export default Nome
</pre>

<p>criou components/layouts/Footer.js (footer) e Navbar.js (navbar) baseados em home</p>

<p>Em App.js (app) importamos footer e navbar, sendo que Navbar fica antes dentro de Router, antes de Routes; Footer
  fica depois de Routes</p>

<p>em navbar importou {Link} de react-router-dom e Logo de assets/img e codou a estrutura nav{div{img;h2} ; ul{li{Link}}
  } ; em Link colocou o atributo "to" que recebe a rota que será colocada na url e no innerHTML de Link o texto a ser
  exibido no link
<ul>
  <li>A estrutura de img é src={"caminho/da/imagem"} e alt="texto alternativo"</li>
</ul>
</p>

<p>em footer vamos colocar a estrutura footer>p>span </p>

<h3>CSS no navbar e footer</h3>

<p>criar layouts/Navbar.module.css e criar os estilos ".navbar", ".navbar_logo", ".navbar_logo img", ".navbar ul",
  ".navbar li, .navbar a", ".navbar li:hover", ".navbar a:hover" </p>

<p>em navbar importar styles de './Navbar.module.css'</p>

<p>ainda em navbar nossa nav receberá a className={styles.navbar}, a primeira div receberá styles.navbar_logo</p>

<p>criar layouts/Footer.module.css e criar os estilos ".footer", </p>

<p>em footer importar styles de './Footer.module.css'</p>

<p>ainda em footer na tag footer colocar a className={styles.footer}</p>

<h3>Criando componente de container</h3>

<p>em app, depois de Navbar vamos colocar a tag Container encapsulando a Routes</p>

<p>vamos importar Container (container) de layouts/Container</p>

<p>criamos esse Container e nele importamos styles de './Container.modules.css' </p>

<p>Em Container.modules.css nós criamos o estilo .container</p>

<p>já em container vamos retornar main com a className={styles.container}
<ul>
  <li>A função Container vai receber como parâmetro um objeto com o valor children</li>
  <li>{children} será usada como valor dentro da tag main retornada pelo container</li>
  <li>essa tag serve para indicar ao React que as tags filhas do elemento devem ser exibidas</li>
</ul>
</p>

<h3>Criando página e form de registro</h3>

<p>em register vamos colocar, depois do h1, um form</p>

<p>vamos criar components/form/Input.js (input) e Input.module.css (input-css), que será o módulo de elementos e input
  que usaremos no sistema</p>

<pre>
    import styles from './Input.module.css'

    function Input({
    type,
    text,
    name,
    placeholder,
    handleOnChange,
    value,
    multiple,
    }) {
    return (
        div
            label htmlFor={name}>{text}:/label>
            input
                type={type}
                name={name}
                id={name}
                placeholder={placeholder}
                onChange={handleOnChange}
                value={value}
                {...(multiple ? { multiple } : '')}
        div
        />
    )
    }

    export default Input
</pre>

<p>Os atributos de Input serão determinados na chamada do módulo na página que o utilizar</p>

<p>o "onChange" utilizado no input é nativo do react para a criação de um event listener no input</p>

<p>em register importamos input e criamos inputs componentizados para nome, telefone, e-mail, senha, confirmação de
  senha</p>

<p>depois dos componentizados criamos um input submit para "Cadastrar" os dados</p>

<p>em input-css criamos a classe .form_control, ".form_control label", ".form_control input", ".form_control
  input::placeholder </p>

<p>em input nós vamos encapsular todo o retorno em uma div com className={styles.form_control}</p>

<p>vamos criar components/forms/Form.module.css (form-css) e importar isso em register</p>

<p>em form-css vamos estilizar .form_container, ".form_container input[type='submit']", ".form_container
  input[type='submit']:hover", ".form_container p", ".form_container p a" </p>

<p>a section de register receberá o className={styles.form_container}</p>

<p>em register importamos {Link} de react-router-dom </p>

<p>Ainda em register, antes do fim da section nós criamos um p que pergunta para o usuário se ele já tem conta,
  direcionando para a página de login a partir da tag Link</p>

<h3>Criando um objeto de usuário</h3>

<p>em register importamos useState de react</p>

<p>usamos useState dentro do Register, usando user e setUser como atributos do useState, sendo que o estado inicial de
  user é um objeto vazio</p>

<p>na função handleChange nós vamos executar o método setUser, recebendo como primeiro argumento um spread de user e
  como segundo, a definição de um novo par atributo:valor, sendo atributo o e.target.name e o valor e.target.value</p>

<p>nós criamos a função handleSubmit que executa e.preventDefault()</p>

<p>no form do return nós definimos o atributo onSubmit passando a função handleSubmit</p>

<h3>Criando hook de autenticação</h3>

<p>criamos src/utils/api.js e fazemos:
<pre>
        import axios from 'axios'

        export default axios.create({
            baseURL:'http://localhost:5000'
        })
    </pre>
</p>

<p>utils/api.js é usado para fazer a conexão com a api, o baseURL já foi usado para não precisarmos escrever isso nas
  muitas chamadas dessa função ao longo do projeto</p>

<p>criamos src/hooks/useAuth.js (useAuth) e fazemos
<pre>
    import api from '../utils/api'

    import { useState, useEffect } from 'react'
    import { useHistory } from 'react-router-dom'

    export default function useAuth() {
        async function register(user){
            try {
                const data = await api.post('/users/register', user).then((response) => {
                    return response.data
                })
            } catch (error) {
                // tratar erro
                console.error(error)
            }
        }
        
        return {register}
    }
</pre>
</p>

<p>pelo visto o axios cria uma requisição com o corpo configurado no segundo argumento do método post, mandando para a
  url especificada pela baseURL + a extensão passada como primeiro argumento</p>

<h3>Criando contexto de usuário</h3>

<p>criar src/context/UserContext.js essa é a convenção de nomenclatura de contextos no react</p>

<p>Imagino que contexto é o conjunto específico de dados de um usuário, então, dependendo do usuário teremos um nome
  mostrado, cores diferentes, etc... Ainda carece de estudos para melhor entendimento.</p>

<p>em UserContext fazemos:
<pre>
        import React, { createContext } from "react";

        import useAuth from "../hooks/useAuth";

        const Context = createContext();

        function UserProvider({ children }) {
        const { register } = useAuth();

        return (
            Context.Provider
            value={{ register }}
            >
            {children}
            /Context.Provider>
        );
        }

        export { Context, UserProvider };
    </pre>
</p>

<p>em app nós importamos {UserProvider} de UserContext e encapsulamos tudo depois de Router com a tag UserProvider,
  dessa forma, todos os componentes encapsulados tem a possibilidade de acessar o contexto do usuário</p>

<h3>Executando rota da API no formulário</h3>

<p>em register nós vamos importar {Context} de UserContext, useContext de react, </p>

<p>ainda em register, antes da função handleChange eu desestruturo register de useContext(Context) </p>

<p>em handleSubmit nós adicionamos register(user)</p>

<p>para realizar testes a partir de agora o backend precisa estar em execução</p>

<h3>Criando hook de flash message</h3>

<p>criamos hooks/useFlashMessage.js</p>

<p>criamos utils/bus.js importando EventEmitter de events e exportamos default new EventEmitter()</p>

<p>bus é uma técnica comum para disparar eventos para componentes</p>

<p>em useFlashMessage nós fazemos:
<pre>
    import bus from '../utils/bus'

    export default function useFlashMessage() {
        function setFlashMessage(msg, type) {
            bus.emit('flash', {
            message: msg,
            type: type,
            })
        }

        return { setFlashMessage }
    }
    </pre>
</p>

<p>isso cria a estrutura para exibição de mensagens para o usuário, seja de sucesso, seja de erros</p>

<p>emit é a emite um evento no sistema com o nome que nós determinamos, no caso determinamos o nome flash. Esse evento
  carrega informações básicas que são definidas no seu segundo parâmetro</p>

<h3>Criando componente de mensagem</h3>

<p>criar layout/Message.js (message) e Message.module.css (message-css)</p>

<p>em message importamos useState de react e styles de message-css ; criamos a função Message e depois a exportamos</p>

<p>dentro da função principal nós usamos um useState que começa como uma string vazia</p>

<p>retornamos uma div estilizada com a mensagem</p>

<pre>
    <code>
        import { useState } from "react";

        import styles from "./Message.module.css";

        function Message() {
            let [type, setType] = useState("");
            return (
                div className={`${styles.message} ${styles[type]}`}>Minha mensagem/div>
            )
        export default Message;
    </code>
</pre>

<p>em app nós importamos message e colocamos a tag de mensagem entre a navbar e o container</p>

<p>mexemos no message-css</p>

<h3>Finalizando componente de flash message</h3>

<p>em message criamos dois states: visibility(false) e message('')</p>

<p>no return nos conectamos visibility à da div de mensagem com o operador &&
<ul>isso fará com que a div só apareça caso o estado de visibility seja true</ul>
</p>

<p>o inner da div de mensagem será o state message</p>

<p>importa e usa useEffect</p>

<p>importa bus</p>

<p>depois dos useState ele declara um useEffect, passando como segundo argumento um array vazio e como primeiro
  argumento uma arrow function que executa o seguinte: </p>

<pre>
    bus.addListener('flash',({message,type}) => { 
        setVisibility(true)
        setMessage(message)
        setType(type)

        setTimeout(()=>{
            setVisibility(false)
        },3000) 
    })
</pre>

<p>em useAuth nos importamos useFlashMessage</p>

<p>na exportação de useAuth nós desestruturamos o método setFlashMessage</p>

<p>na função register, fora do try, nós declaramos um let com uma mensagem de sucesso e uma com um type de success</p>

<p>no catch nós redefinimos os lets para a mensagem vinda de error.response.data.message e o type será de error</p>

<p>depois do try...catch nós vamos executar a função setFlashMessage passando a mensagem e o tipo como parâmetros</p>

<h3>Autenticando usuário</h3>

<p>em useAuth nós criamos um useState authenticated = (false)</p>

<p>em useAuth criamos a async function authUser(data){}</p>

<pre>
    async function authUser(data){
        setAuthenticated(true)
        localStorage.setItem('token', JSON.stringfy(data.token))
        useHistory().push('/') //redireciona para a rota /
    }
</pre>

<p>no try de register, depois da execução do then da promise executamos o método await authUser(data)</p>

<p>vamos retornar authenticated de useAuth, além de register</p>

<p>esse authenticated será desestruturado de useAuth na função UserProvider em UserContext e recebido como value em
  Context.Provider neste mesmo context </p>

<p>em useAuth, antes das funções definimos o seguinte useEffect</p>

<pre>
    useEffect(() => {
        const token = localStorage.getItem('token')
        if(token){
            api.defaults.headers.Authorization = `Bearer ${JSON.parse(token)}`
            setAuthenticated(true)
        }
    },[])
</pre>

<p>substituir useHistory por useNavigate; onde dou useHistory().push('/') devo substituir por useNavigate('/')</p>

<p>tirar o manifest.json da página public/index.html</p>

<h3>Persistindo autenticação do usuário no front </h3>

<p>navbar -> importar {Context} de UserContext e {useContext} de react -> na função declarar o const {authenticated} =
  useContext(Context) ->
<ul>nós temos acesso ao contexto por termos envolvido a aplicação com o UserProvider</ul>
<ul>authenticated é setado como true quando passamos pelo hook do useAuth</ul>
</p>

<p>ainda na função de navbar nós vamos criar uma condicional logo após o link de Adotar que verifica o authenticated,
  sendo que no caso de estar autenticado é renderizada uma tag p com inner "Logado" ou então, no caso de não estar
  autenticado, o conjunto de links de Entrar e Cadastrar</p>

<h3>Função de logout</h3>

<p>dentro da função de useAuth nós vamos criar a função logout onde vamos declarar constantes de mensagem, uma contendo
  o texto e outra o tipo (success)</p>

<pre>
    <code>
        function logout() {
          const msgText = 'Logout realizado com sucesso!'
          const msgType = 'success'
      
          setAuthenticated(false)
          localStorage.removeItem('token')
          api.defaults.headers.Authorization = undefined
          navigate('/')
      
          setFlashMessage(msgText, msgType)
        }        
    </code>
</pre>

<p>ainda na função de useAuth nós vamos exportar a função de logout</p>

<p>importamos a função de logout em UserContext colocando-a também como um dos values de ContextProvider no contexto</p>

<p>em navbar importar logout de useContext(Context)</p>

<p>em navbar alterar a tag p que aparece quando o usuário está autenticado para uma li que executa o método logout
  quando do evento onClick </p>

<h3>Formulário de login</h3>

<p>na página de login nós vamos importar useState e useContext de react, importar {Link} de react-router-dom, importar
  Input de form/Input, importar styles também de form, importar {Context} de UserContext</p>

<p>vamos retornar na função do login uma section com className={styles.form_container} que encapsula um h1 e um form que
  encapsula os módulos de Input para email e senha, tendo esses módulos o eventlistener handleOnChange={handleChange}
</p>

<p>a função handleChange deve ser declarada na função de login, mas antes do retorno</p>

<p>depois dos Inputs é colocada uma tag input:submit(Entrar) e depois do form uma p com um Link que direciona para a
  página de regitro, caso o usuário ainda não seja registrado</p>

<h3>Função de login</h3>

<p>em useAuth criamos uma função assíncrona login(user) onde vamos declarar as let iniciais da mensagem de login e do
  seu tipo e depois vamos dar um try...catch(error) </p>

<p>no try nós vamos fazer o seguinte</p>

<pre>
  <code>
    const data = await api.post('/users/login', user).then((response) => {
      return response.data
    })

    await authUser(data)
  </code>
</pre>

<p>no catch vamos passar que a mensagem de login será error.response.data.message, com type error</p>

<p>depois do try...catch nós executamos o setFlashMessage(message, type)</p>

<p>passamos a função login como retorno de useAuth e usamos também em UserContext</p>

<p>na página de login, em sua função, nós vamos declarar const [user,setUser] = useState({}) e const {login} =
  useContext(Context) </p>

<p>logo depois dessas declarações nós declaramos a função handleChange(e) que executar o
  setUser({...user,[e.target.name]:e.target.value})</p>

<p>o form do retorno terá o eventlistener onSubmit que executará a função handleSubmit</p>

<p>a função handleSubmit(e) será declarada depois de handleChange, que vai executar e.preventDefault() e login(user)
</p>

<h3>Criando página de perfil</h3>

<p>criar pages/User/Profile.js e Profile.module.css</p>

<p>em Profile vamos copiar tudo da Home, alterando de Home para Profile onde é de direito</p>

<p>em app vamos importar a página Profile e vamos criar uma rota para ela na função principal colocando o componente
  Profile no Router</p>

<p>em navbar vamos criar o Link para a página de perfil quando o usuário está autenticado</p>

<h3>Formulário de edição do usuário</h3>

<p>iremos criar um formulário de edição de usuário</p>

<p>no início da página profile vamos importar os styles de Profile.module.css e formStyles de components/form, importar
  também o componente de Input</p>

<p>vamos importar useState e useEffect de react</p>

<p>vamos criar um form.form_container com Inputs de imagem, email, nome, telefone, senha e confirmação de senha
<ul>
  <li>
    o handleOnChange do Input de imagem receberá o método onFileChange, diferentemente dos outros Inputs, que terão o
    método tradional handleChange
  </li>
  <li>todos os Inputs, com exceção de senha e sua confirmação terão um value={user.nome_do_campo}</li>
</ul>
</p>

<p>os métodos handleChange e onFileChange devem ser declarados antes do retorno</p>

<p>antes dos métodos vamos criar const [user,setUser] = useState({}) para depois popularmos com os dados do usuário que
  serão carregados quando do carregamento da página, através do useEffect</p>

<p>depois dos Inputs nós criamos um input:submit com o value="Editar"</p>

<p>vamos definir algumas regras de css em Profile.module.css</p>

<h3>Resgatando usuário para preencher o formulário</h3>

<p>na página de profile, importamos a api a partir de utils</p>

<p>na função principal, nós declaramos token = localStorage.getItem('token') || ''</p>

<p>depois utilizamos o useEffect da seguinte forma:</p>

<pre>
    <code>
        useEffect(() => {
            api.get('/users/checkUser', {
            headers: {
                Authorization: `Bearer ${JSON.parse(token)}`,
            },
            })
            .then((response) => {
            setUser(response.data)
            })
        }, [token])
    </code>
</pre>

<p>Interessante notar que o token é usado como parâmetro para o acionamento do useEffect</p>

<h3>Atualizando dados do usuário</h3>

<p>em Profile.js no método handleChange eu vou executar o método setUser({...user,[e.target.name]:e.target.value})</p>

<p>em onFileChange vamos executar o mesmo método, porém a única diferença é substituir value por files[0]</p>

<p>importar useFlashMessage e desestruturar setFlashMessage dela</p>

<p>criar a função assíncrona handleSubmit da seguinte forma:</p>

<pre>
  <code>
    async function handleSubmit(e){
      e.preventDefault()
      let msgType = 'success'

      const formData = new FormData()
  
      await Object.keys(user).forEach((key) =>
      formData.append(key, user[key]),
      )
  
      const data = await api.patch(`/users/edit/${user._id}`, formData, {
          headers: {
          Authorization: `Bearer ${JSON.parse(token)}`,
          'Content-Type': 'multipart/form-data',
          },
      })
      .then((response) => {
          console.log(response.data)
          return response.data
      })
      .catch((err) => {
          console.log(err)
          msgType = 'error'
          return err.response.data
      })

      setFlashMessage(data.message, msgType)
    }
      
  </code>
</pre>

<p>colocar a função handleSubmit na espera do submit do form </p>

<h3>Atualização de imagem do usuário</h3>

<p>criar o state preview( )
  <ul>
    <li>preview é a imagem que está sendo selecionada para o carregamento, mas que ainda não está inserida como imagem atual do usuário no banco de dados</li>
  </ul>
</p>

<p>depois do título da página nós vamos fazer uma condicional para mostrar a imagem conforme código abaixo:</p>

<pre>
  <code>
    {(user.image || preview) && (
      img  
        src={
          preview
            ? URL.createObjectURL(preview)
            : `${process.env.REACT_APP_API}/img/users/${user.image}`
        }
        alt={user.name}
      />
    )}
  </code>
</pre>

<p>em onFileChange nós adicionamos o método setPreview(e.target.files[0]) </p>

<h3>Criando componente de imagem</h3>

<p>criar layout/RoundedImage.js e RoundedImage.module.css</p>

<p>em RoundedImage vamos importar styles de module.css e na função vamos receber um objeto {src,alt,width}</p>

<p>o return da função principal é uma img com os seguintes atributos:</p>

<pre>
  <code>
    img
      className={`${styles.rounded_image} ${styles[width]}`}
      src={src}
      alt={alt}
    />
  </code>
</pre>

<p>arrumar o css em module.css</p>

<p>em Profile vamos alterar a tag img da imagem do usuário para a tag RoundedImage, devidamente importada</p>

<h3>Criando página de lista de pets</h3>

<p>criar pages/Pet/MyPets.js onde colocaremos os pets nossos que iremos por para adoção</p>

<p>na navbar vamos criar um Link para mypets que será uma rota de pet e em app uma rota para mypets</p>

<p>na página mypets vamos importar useState e useEffect, {Link} de react-router-dom </p>

<p>na função vamos criar o state pets([])</p>

<p>no retorno vamos criar uma div depois do título onde vamos renderizar uma tag p="Meus pets cadastrados" se pets.length > 0 ou uma tag p="Não há pets cadastrados" se pets.length === 0 </p>

<p>vamos envolver o título h1 em uma div, onde além desse h1 haverá um Link para a página de cadastro de pets = '/pet/add'="Cadastrar pet"</p>

<h3>Página de cadastro do pet</h3>

<p>vamos criar pages/Pet/AddPet.js e AddPet.module.css, colocando uma rota para ela em App</p>

<p>no retorno de addpet vou fazer:</p>

<pre>
  <code>
    section>
      div>
        h1> Cadastre um pet
        p>
  </code>
</pre>

<p>arrumar o css de AddPet.module.css, depois importar esses estilos para addpet e utilizá-los nessa página</p>

<p>importar a api de utils, useState, useNavigate, useFlashMessage</p>

<h3>Início do form de pet</h3>

<p>vamos criar components/form/PetForm.js</p>

<p>em petform vamos importar useState, Form.module.css e Input</p>

<p>a função vai receber as props { handleSubmit, petData, btnText } </p>

<p>na função vamos definir as consts a seguir:</p>

<pre>
  const [pet, setPet] = useState(petData || {})
  const [preview, setPreview] = useState([])
  const colors = ['Branco', 'Preto', 'Cinza', 'Caramelo']
</pre>

<p>no return vamos criar um form."formStyles.form_container" com Inputs de imagens, nome, idade, peso 
  <ul>
    <li>o Input de imagens vai ter o parâmetro multiple={true} indicando que haverá o envio de múltiplas imagens</li>
    <li>se Input for de imagem handleOnChange=onFileChange, se não, =handleChange<li>
    <li>com exceção do Input de imagem, os Inputs terão value={pet.atributo || ''} e placeholder</li>
  </ul>
</p>

<p>ao final teremos um input submit = "Cadastrar Pet"</p>

<p>importamos petform em addpet e usamos sua tag no fim do retorno de addpet</p>

<p>criar form/Select.js e Select.module.css</p>

<p>em select vamos importar os styles de module.css, onde já podemos colocar os códigos</p>

<p>a função vai receber as props { text, name, options, handleOnChange, value} </p>

<p>o retorno será o seguinte:</p>

<pre>
  div className={styles.form_control}>
    label htmlFor={name}>{text}:/label>
    select
      name={name}
      id={name}
      onChange={handleOnChange}
      value={value || ''}
    >
      option>Selecione uma opção/option>
      {options.map((option) => (
        option value={option} key={option}>
          {option}
        /option>
      ))}
    /select>
  /div>
</pre>

<ul>Detalhes do map do retorno de select
  <li>importante notar que no map de options nós usamos parênteses e não chaves para executar a função de callback, isso acontece por estarmos retornando .jsx quando trabalhamos com react</li>
  <li>outro detalhe é essa key. Quando estamos trabalhando com um elemento que se repete em react temos que usar esse atributo, que é como se fosse um id dessa opção</li>
</ul>

<p>em petform vamos criar a função handleColor</p>

<p>importar select para petform e colocá-lo antes do input:submit</p>

<h3>Terminando o formulário de pet</h3>

<p>em petform vamos completar o onFileChange, onHandleChange e handleColor e o onFormSubmit</p>

<p>importante notar que no onFileChange temos que colocar o método setPreview que vai popular o array de preview, inicialmente vazio. Para tanto, temos que transformar o retorno de e.target.files em um array, a partir de Array.from, uma vez que aquele retorno é de uma lista de arquivos e não um array propriamente dito</p>

<p>em Form.module.css vamos criar regras para o form de pets, e vamos aplicar no petform</p>

<p>no form, antes dos Inputs nós vamos colocar uma div que exibirá as imagens enviadas por preview ou as imagens já cadastradas do pet ou absolutamente nada. O código para isso é o seguinte:</p>

<pre>
  div className={formStyles.preview_pet_images}>
    {preview.length > 0
      ? preview.map((image, index) => (
          img
            src={URL.createObjectURL(image)}
            alt={pet.name}
            key={`${pet.name}+${index}`}
          />
        ))
      : pet.images &&
        pet.images.map((image, index) => (
          img
            src={`${process.env.REACT_APP_API}/img/pets/${image}`}
            alt={pet.name}
            key={`${pet.name}+${index}`}
          />
        ))}
  /div>
</pre>

<h3>Conclusão da tela de adicionar pet</h3>

<p>em addpet vamos criar a async function registerPet(pet) que será passada como valor do parâmetro handleSubmit na tag PetForm </p>

<p>vamos declarar em addpet as consts:</p>

<pre>
  const [token] = useState(localStorage.getItem('token') || '')
  const { setFlashMessage } = useFlashMessage()
  const navigate = useNavigate()
</pre>

<p>na função registerPet vamos fazer:</p>

<pre>
  let msgType = 'success'

  const formData = new FormData()

  Object.keys(pet).forEach((key) => {
    if (key === 'images') {
      for (let i = 0; i menor que pet[key].length; i++) {
        formData.append(`images`, pet[key][i])
      }
    } else {
      formData.append(key, pet[key])
    }
  })

  const data = await api
    .post(`/pets/create`, formData, {
      headers: {
        Authorization: `Bearer ${JSON.parse(token)}`,
        'Content-Type': 'multipart/form-data',
      },
    })
    .then((response) => {
      return response.data
    })
    .catch((err) => {
      msgType = 'error'
      return err.response.data
    })

  setFlashMessage(data.message, msgType)
  if(msgType !== 'error'){
    navigate('/pet/mypets')
  }
</pre>

<ul>algumas considerações da função registerPet
  <li>formData é usado, assim como no caso do perfil do usuário, para conseguirmos passar imagens</li>
  <li>no populamento de formData há a separação entre as imagens e os outros dados, isso se dá porque pode vir mais de uma imagem do pet, que devem ser agrupadas juntas em um array</li>
</ul>

<h3>Requisição para pegar pets cadastrados</h3>

<p>em mypets vamos importar RoundedImage, api e useFlashMessage</p>

<p>em mypets vamos declarar o token e setFlashMessage</p>

<p>vamos usar useEffect para carregar os pets do usuário logado da seguinte forma</p>

<pre>
  useEffect(() => {
    api
      .get('/pets/mypets', {
        headers: {
          Authorization: `Bearer ${JSON.parse(token)}`,
        },
      })
      .then((response) => {
        setPets(response.data.pets)
      })
  }, [token])
</pre>

<h3>Exibindo os pets na dashboard</h3>

<p>vamos criar pages/Pet/Dashboard.module.css e importar em mypets</p>

<p>em mypets vamos substituir o texto "Meus pets cadastrados." pelo seguinte map de pets:</p>

<pre>
  pets.map((pet) => (
    div key={pet._id}>
      RoundedImage
        src={`${process.env.REACT_APP_API}/img/pets/${pet.images[0]}`}
        alt={pet.name}
        width="px75"
      />
      span>{pet.name}/span>
      div>
        {pet.available ? (
          >
            {pet.adopter && (
              button>
                Concluir adoção
              /button>
            )}

            Link to={`/pet/edit/${pet._id}`}>Editar/Link>
            button>
              Excluir
            /button>
          />
        ) : (
          p>Pet já adotado/p>
        )}
      /div>
    /div>
  )
</pre>

<h3>CSS da dashboard</h3>

<p>em Dashboard.module.css vamos criar o css e depois vamos ir aplicando as classes nos respectivos elementos de MyPets</p>

<h3>Removendo pet do sistema</h3>

<p>em mypets criamos a função assíncrona removePet(id), onde vamos fazer o seguinte:</p>

<pre>
  async function removePet(id) {
    let msgType = 'success'

    api.delete(`/pets/${id}`, {
        headers: {
          Authorization: `Bearer ${JSON.parse(token)}`,
        },
      })
      .then((response) => {
        const updatedPets = pets.filter((pet) => pet._id !== id) //pega o array de pets que está renderizado na tela e filtro por aqueles que tem o id diferente do pet deletado
        setPets(updatedPets) //altero o array dos pets renderizados para o updatedPets, o qual não tem o pet deletado do banco de dados.
        //a técnica acima faz o tratamento da exibição apenas do front-end, poupando tráfego de rede
        return response.data
      })
      .catch((err) => {
        msgType = 'error'
        return err.response.data
      })

    setFlashMessage(data.message, msgType)
  }
</pre>

<p>no botão de Excluir vamos colocar um atributo onClick passando o método removePet dentro de uma função anônima</p>

<h3>Página de edição do pet</h3>

<p>em mypets, no Link de Editar, vamos colocar o path `/pet/edit/$pet._id}`</p>

<p>criar a página pages/Pet/EditPet.js</p>

<p>em editpet vamos importar a api, useState, useEffect, styles de addpet.module.css, petform, useFlashMessage, importar também useParams de react-router-dom</p>

<p>useParams é usado para trabalharmos com os dados passados na url</p>

<p>em app vamos colocar nas rotas a página editpet com o path 'pet/edit/:id'</p>

<p>no retorno de editpet vamos colocar uma div de cabeçalho com um h1</p>

<p>na função de editpet vamos declarar:</p>

<pre>
  const [pet, setPet] = useState({})
  const [token] = useState(localStorage.getItem('token') || '')
  const { id } = useParams() //isso funciona porque no app nós chamamos essa página através do path com :id, que é referenciado na desestruturação
  const { setFlashMessage } = useFlashMessage()
</pre>

<p>depois dessas variáveis vamos declarar o useEffect a seguir:</p>

<pre>
  useEffect(() => {
    api.get(`/pets/${id}`, {
        headers: {
          Authorization: `Bearer ${JSON.parse(token)}`,
        },
      })
      .then((response) => {
        setPet(response.data.pet)
      })
  }, [token, id])
</pre>

<p>criar o método updatePet(pet){}</p>

<p>no retorno de editpet fazemos:</p>

<pre>
  section>
    div className={styles.addpet_header}>
      h1>Editando o Pet: {pet.name}/h1>
      p>Depois da edição os dados serão atualizados no sistema/p>
    /div>
    {pet.name && (
      PetForm handleSubmit={updatePet} petData={pet} btnText="Editar" />
    )}
  /section>
</pre>

<p>no método updatePet nós fazemos:</p>

<pre>
  let msgType = 'success'

  const formData = new FormData()

  Object.keys(pet).forEach((key) => {
    if (key === 'images') {
      for (let i = 0; i menor que pet[key].length; i++) {
        formData.append(/*`images` teste*/ key, pet[key][i])
      }
    } else {
      formData.append(key, pet[key])
    }
  })

  const data = await api.patch(`pets/${pet._id}`, formData, {
      headers: {
        Authorization: `Bearer ${JSON.parse(token)}`,
        'Content-Type': 'multipart/form-data',
      },
    })
    .then((response) => {
      return response.data
    })
    .catch((err) => {
      msgType = 'error'
      return err.response.data
    })

  setFlashMessage(data.message, msgType)
</pre>

<p>no updatePet do server, vamos modificar a validação do envio de imagens por parte do usuário, colocando que haverá alteração do array de imagens apenas se o usuário tiver enviado imagens (images.length > 0)</p>

<h3>Resgatando os pets na home</h3>

<p>em home, importamos api, Link, useState, useEffect</p>

<p>criar pages/Home.module.css</p>

<p>criar o state pets([])</p>

<p>fazemos useEffect da seguinte maneira:</p>

<pre>
  useEffect(() => {
    api.get('/pets').then((response) => {
      setPets(response.data.pets)
    })
  }, [])
</pre>

<p>no retorno da home nós vamos colocar uma div de cabeçalho na section, onde teremos um h1 e um p </p>

<p>depois da div de cabeçalho vamos criar uma div com uma condicional para exibição dos pets cadastrados (pets.length > 0) através de um pets.map ou uma p indicando que não há pets cadastrados</p>

<p>no map de exibição vamos retornar uma div com uma div(que exibirá a imagem), o nome do pet, peso, um ternário verificando se o pet está disponível (available) ou não</p>

<p>na verificação de available, caso esteja disponível vamos colocar retornar um Link para "/pet/${pet._id}"</p>

<p>vamos arrumar o css de Home.module.css e colocar no elementos respectivos</p>

<p>a imagem do pet vai ser dada pelo estilo css inline a seguir:</p>

<pre>
{{backgroundImage: `url({process.env.REACT_APP_API}/img/pets/${pet.images[0]})`}}
</pre>

<h3>Página de detalhes do pet</h3>

<p>criar pages/Pet/PetDetails.js onde vamos criar a função PetDetails que retorna um h1 e ao final vamos exportar PetDetails</p>

<p>criar PetDetails.module.css e vamos importá-la em petdetails</p>

<p>em app vamos colocar a rota de petdetails para "/pet/:id"</p>

<p>em petdetails vamos importar a api, useState, useEffect, useParams, Link, useFlashMessage </p>

<p>na função vamos declarar: </p>

<pre>
  const [pet, setPet] = useState({})
  const { id } = useParams()
  const { setFlashMessage } = useFlashMessage()
  const [token] = useState(localStorage.getItem('token') || '')
</pre>

<p>depois das declarações vamos usar o useEffect para pegar os pets:</p>

<pre>
  useEffect(() => {
    api.get(`/pets/${id}`).then((response) => {
      setPet(response.data.pet)
    })
  }, [id])
</pre>

<p>em petdetails vamos retornar um fragment com uma condicional onde, caso haja pet.name, vamos renderizar uma section que vai ter uma div de cabeçalho e depois tags com os dados do pet</p>

<p>depois dos detalhes, ainda dentro da section, vamos verificar por meio de um ternário se há token, havendo colocamos um botão de solicitação de visita, se não, informar que é necessário estar logado para adotar</p>

<p>vamos criar os estilos css em PetDetails.module.css colocando as respectivas regras nos elementos html de petdetails<p>

<h3>Função de solicitar visita</h3>

<p>em petdetails vamos criar a função assíncrona schedule, ela será associada ao clique botão de solicitação de visita do pet </p>

<pre>
  async function schedule() {
    let msgType = 'success'

    const data = await api
      .patch(`pets/schedule/${pet._id}`, {
        headers: {
          Authorization: `Bearer ${JSON.parse(token)}`,
        },
      })
      .then((response) => {
        return response.data
      })
      .catch((err) => {
        msgType = 'error'
        return err.response.data
      })

    setFlashMessage(data.message, msgType)
  }
</pre>

<h3>Criando página de adoções</h3>

<p>criar pages/Pet/MyAdoptions.js, colocando-a nas rotas de app</p>

<p>vamos colocar essa página também como link na navbar para quando o usuário estiver logado</p>

<p>na página myadoptions vamos importar styles de dashboard.module.css, api, useState, useEffect, RoundedImage</p>

<p>vamos declarar na função as seguintes constantes e useEffect</p>

<pre>
  const [pets, setPets] = useState([])
  const [token] = useState(localStorage.getItem('token') || '')

  useEffect(() => {
    api.get('/pets/myadoptions', {
        headers: {
          Authorization: `Bearer ${JSON.parse(token)}`,
        },
      })
      .then((response) => {
        setPets(response.data.pets)
      })
  }, [token])
</pre>

<p>ainda na página de adoções (myadoptions), vamos retornar uma section com uma div de cabeçalho e outra div com a lista de pets com visita marcada pelo usuário. A lista será alimentada por um map caso pets.length > 0 </p>

<h3>Conclusão da adoção</h3>

<p>em mypets, nós vamos definir o método assíncrono concludeAdoption(id) que será associado ao clique no botão de concluir adoção, sendo passado como parâmetro o pet._id. 
  <ul>
    <li>
      <strong>vale lembrar que para criar a associação de um método com parâmetros a um botão sem executar esse método na montagem da página, é necessário passarmos esse método no onClick dentro de uma função anônima </strong>
    </li>
  </ul> 
</p>

<pre>
  async function concludeAdoption(id) {
    let msgType = 'success'

    const data = await api
      .patch(`/pets/conclude/${id}`, {
        headers: {
          Authorization: `Bearer ${JSON.parse(token)}`,
        },
      })
      .then((response) => {
        return response.data
      })
      .catch((err) => {
        console.log(err)
        msgType = 'error'
        return err.response.data
      })

    setFlashMessage(data.message, msgType)
  }
</pre>


