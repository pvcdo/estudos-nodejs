<h2>Configuração do projeto</h2>

<p>get-a-pet -> pastas (server; client)</p>
<p>pasta server (server) -> npm i bcrypt cookie-parser cors express jsonwebtoken mongoose multer nodemon
    <ul>
        <li>bcrypt = criptografia de senhas</li>
        <li>cookie-parser = </li>
        <li>cors = para podermos mandar requisições para o nosso mesmo domínio. Quando lidamos com front e back há conflitos que este módulo trata</li>
        <li>jsonwebtoken = autenticação de usuários</li>
        <li>multer = upload de fotos (singular e multiplos)</li>
    </ul>
</p>
<p>server -> pastas mvc (menos a de views), db, helpers (funções auxiliares para serem acessadas em várias rotas), public, public/img/users, public/img/pets, routes</p>
<p>index = const express ; const cors ; const app ; app.use(express.json()) ; app.use(cors({credentials: true, origin: 'http://localhost:3000'})) ; app.use(express.static('public')) ; app.listen(5000)
    <ul>
        <li>Não precisaremos de express.urlencoded porque a comunicação será toda por json</li>
        <li>em cors, o origin é o ip do front-end. Como o front e o back estão em localhost o navegador acusaria um erro, que é solucionado com esse middleware</li>
    </ul>
</p>
<p>package.json -> script start nodemon</p>

<h2>Criando models</h2>

<p>db/conn.js = { const mongoose ; mongoose.connect(uri) then {console ; module.exports = mongoose} }</p>
<p>models/User.js = { const mongoose ; const {Schema} = mongoose ; const User = mongoose.model('nome banco', new Schema({atributos}, {timestamps: true})) ; module.exports = User}
    <ul>
        <li>o timestamps vai criar os campos createdAt e updatedAt, registrando quando o dado foi criado e atualizado, respectivamente</li>
    </ul>
</p>
<p>models/Pet.js = { const mongoose ; const {Schema} = mongoose ; const User = mongoose.model('nome banco', new Schema({atributos}, {timestamps: true})) ; module.exports = User}</p>

<h2>Criando rotas de usuários</h2>

<p>routes/UserRoutes.js (ur)</p>
<p>controllers/UserController.js (uc)</p>
<p>index -> app.use('/users',require('./routes/UserRoutes'))</p>
<p>UserRoutes = { const router ; router.post('/register', uc.register) ; module.exports = router }</p>
<p>uc = { const User = require(model) ; exports = class UserController { static async register { res.json 'Estamos registrando um usuário' } } }</p>
<p>no postman criar a collection pro projeto, dentro dessa collection outras duas, uma para Users e outra para Pets</p>
<p>criar a variável url com o valor http://localhost:5000</p>
<p>testar a rota register de user no postman</p>

<h2>Validação de usuários</h2>

<p>uc.register -> receber os atributos de usuário a partir de req.body ; validar se: 
    <ul>
        <li>todos atributos vieram</li>
        <li>senha e confirmação de senha iguais</li>
        <li>usuário já existe no banco de dados (User.findOne({email})</li>
    </ul>
</p>
<p>todas falhas de verificação retornam um status de 422</p>

<h2>Registrando usuário no banco</h2>

<p>uc -> import bcrypt</p>
<p>uc.register -> {... ; salt ; passwordHash ; user = new User({atributos {... , password: passwordHash}}) ; try new_user = await user.save();  res.status(201).json({message, new_user}), catch(e) status(500).json({message})} </p>

<h2>Retornando o token JWT (json web token)</h2>

<p>criar helpers/create-user-token.js = { require(jsonwebtoken) ; function createUserToken(user,req,res){const token = jwt.sign({name:user.name,id:user._id},"nossosecret") ; res.status(200).json({message,token,userId:user._id})} ; module.exports = createUserToken }</p>

<p>uc -> require create-user-token</p>

<p>uc.register -> apagar try catch final e dar um createUserToken passando o usuário registrado, req e res</p>

<h2>Função de login no sistema</h2>

<p>ur -> post('/login', uc.login)</p>

<p>uc ->  async login { const email, password = req.body ; validações email e senha ; checar User.findOne({email}) ; checar bcrypt.compare(senha_front, user.password) /*o primeiro atributo é a senha que foi fornecida no formulário de login, o segundo a senha que está no banco de dados para aquele usuário*/ ; await createUserToken(user) }</p>

<h2>Verificando usuário pelo token</h2>

<p>uc -> async checkUser { let currentUser ; console.log(req.headers.authorization) ;/*as: auth*/ if(req.headers.authorization){}else{currentUser = null} ; req.status(200).send(currentUser) ; } </p>

<p>ur -> get('checkUser', uc.checkUser)</p>

<p>postman -> get {{url}}/users/checkUser ; get-a-pet => variables => TOKEN => token de post users/login ; get checkUser => authorization => type = bearer token = {{TOKEN}} /*ao enviar deve aparecer o token no cmd*/ </p>

<p>helpers/get-token.js -> { const getToken(req){ const authHeader = req.headers.authorization ; const token = authHeader.split 1 ; return token } ; module.exports = getToken } </p>

<p>uc -> import helpers/get-token ; import jwt</p>

<p>uc.checkUser -> auth: {const = getToken(req) ; const decoded = jwt.verify(token,'nossosecret') ; currentUser = await User.findById(decoded.id) ; currentUser.password = undefined }</p>

<h2>Pegar usuário pelo id</h2>

<p>ur -> get('/:id',uc.getUserById)</p>

<p>uc -> async getUserById { const id = req.params ; const user = await User.findById(id).select("-password") ; if(!user){res.status(422).json("nao encontrado") return } ; res.status(200).json(user)  } 
    <ul>
        <li>o método select usado no findById indica que vamos excluir o campo password do retorno do método findById</li>
        <li>outra forma já abordada de não termos o password exposto é atribuirmos undefined à user.password</li>
    </ul>
</p>

<h2>Verificação do token do usuário</h2>

<p>ur -> patch('/update/:id',uc.updateUser)
    <ul>
        <li>patch é um método http usado para atualizar dados</li>
    </ul>
</p>

<p>Vamos criar uma função helper para verificar o token do usuário, caso exista um token e este seja válido o usuário poderá entrar na rota de update</p>

<p>//verify-token.js
    const jwt = require("jsonwebtoken");
    const getToken = require("./get-token")

    // middleware to validate token
    const checkToken = (req, res, next) => {
        if(!req.headers.authorization){
            return res.status(401).json({ message: "Acesso negado!" });
        } 

        const token = getToken(req)
        if(!token){
            return res.status(401).json({ message: "Acesso negado!" });
        }

        try {
            const verified = jwt.verify(token, "nossosecret");
            req.user = verified;
            next(); // to continue the flow
        } catch (err) {
            res.status(400).json({ message: "O Token é inválido!" });
        }
    };

    module.exports = checkToken;
</p>

<p>ur -> import verify-token</p>

<p>ur -> .patch('/update/:id',verify-token, ... ) </p>

<p>uc -> async updateUser(r,r){ res.status(200).json("deu certo") }</p>

<h2>Atualizações usuário</h2>

<p>// helpers/get-user-by-token.js
    const jwt = require("jsonwebtoken");
    const User = require("../models/User")

    const getUserByToken = async (token) => {
        if(!token){
            return res.status(401).json({ message: "Acesso negado!" });
        } 

        const verified = jwt.verify(token,"nossosecret")
        const _id = verified.id
        const user = await User.findOne({_id})
        return user
    };

    module.exports = getUserByToken;
</p>

<p>uc -> import get-user-by-token</p>

<p>uc.updateUser = { const id = params ; const user = await get-user-by-token(get-token(req)) ; const {name,email,phone,password,confirm_password} = body ; let image = "" ; validações de name, email e phone dos const.body ; após cada validação o valor do atributo do usuário será atualizado para o valor enviado pelo body } </p>

<p>postman</p>

<p>uc.updateUser = { ... ; validação de password e confirm ; try{ await User.findOneAndUpdate({_id:id}, {$set:user}, {new:true}) }catch(e){res de erro} } 
    <ul>
        <li>no objeto $set:user eu entendo que serão atualizados todos os atributos do documento encontrado pelo filtro que foi passado como primeiro parâmetro do método findOneAndUpdate</li>
    </ul>
</p>

<p>postman tentando dar login com dados velhos e novos</p>

<h2>Upload de imagem</h2>

<p>// helper/image-upload.js
    const multer = require("multer");
    const path = require("path");

    // Destination to store image
    const imageStorage = multer.diskStorage({
    destination: function (req, file, cb) {
        let folder = "";

        console.log(req)

        if (req.baseUrl.includes('users')) {
        folder = "users";
        } else if (req.baseUrl.includes('pets')) {
        folder = "pets";
        }
        cb(null, `public/img/${folder}/`);
    },
    filename: (req, file, cb) => {
        cb(null, Date.now() + path.extname(file.originalname));
    },
    });

    const imageUpload = multer({
    storage: imageStorage,
    fileFilter(req, file, cb) {
        if (!file.originalname.match(/\.(png|jpg)$/)) {
        // upload only png and jpg format
        return cb(new Error("Por favor, envie apenas png ou jpg!"));
        }
        cb(undefined, true);
    },
    });

    module.exports = { imageUpload };
    <ul>
        <li>usou regex para validar se a imagem enviada era jpg ou png</li>
    </ul>
</p>

<p>ur -> const {imgUpload} = require image-upload</p>

<p>ur.patch('/update/:id',...,imgUpload.single('image'),...}
    <ul>
        <li>o método single é usado para imagens únicas, ainda utilizaremos envio de várias imagens para os pets através do multer</li>
        <li>no caso o middleware imgUpload vai ver se foi recebido pelo formulário</li>
    </ul>
</p>

<p>uc.updateUser -> { ... ; apagar let image ; if(req.file){user.image = req.file.filename} }</p>

<p>postman.updateUser = alterar envio do body de raw para form-data ; alterar o tipo da key image para file (diferente de text que é o padrão)</p>

<!-- PRATICAR A PARTIR DAQUI -->
<!-- *************************************************************** -->

<h2>Iniciando rota de pets</h2>

<p>routes/PetRoutes.js (pr)</p>

<p>pr -> const PetController</p>

<p>pr -> post('create',pc.create)</p>

<p>PetController (pc)</p>

<p>pc -> const User ; const Pet</p>

<p>pc.create(r,r)=>{res.json sucesso}</p>

<p>index -> const PetRoutes ; app.use('/pets',pr)</p>

<p>postman/pets -> post /pets/create</p>

<h2>Salvando pets no sistema</h2>

<p>pr -> const verifyToken
    <ul><li>não queremos que alguem não autenticado salve um pet</li></ul>
</p>

<p>pr -> post('create',verifyToken,...)</p>

<p>postman -> testar post create sem e com token em authorization</p>

<p>pc.create -> const name, age, weight, color = req.body ; const avaiable = true ; validações dos req.body</p>

<p>postman.post(create) -> body-raw-completar o body</p>

<p>pc -> //helpers = { const getToken ; const getUserByToken }</p>

<p>pc.create -> //get pet owner = { const token = await getToken(req) ; const user = await getUserByToken(token) }  ; //create a pet = { const pet = new Pet({atributos + user}) } ; try{ const newPet = await pet.save() ; json {sucesso ; newPet} }catch(e){json erro}</p>

<h2>Upload de múltiplas imagens</h2>

<p>pr -> const {imgUpload} = require(helpers/image-upload)</p>

<p>pr -> post('create',...,imgUpload.array('images'),...)  </p>

<p>pc.create -> { const images = req.files ; verificar se images veio na requisição ; //depois de new Pet = { images.forEach((image) => { pet.images.push(image.filename) }) } } </p>

<p>helpers/image-upload -> incrementar o nome da imagem, uma vez que as imagens são upadas muito rapidamente e o nome é baseado no horário de envio (ele usou Math.random para solucionar isso e eu adicionei os 5 primeiros caracteres do token do usuário)</p>

<p>postman -> post.create = body-form_data</p>

<h2>Função de resgatar todos os Pets</h2>

<p>pr -> get('/',pc.getAll ) </p>

<p>pc.getAll(r,r){ const pets = await Pet.find().sort('-createdAt') //nesse caso ele vai ordenar do mais último cadastrado ao primeiro (Z à A) ; json{sucesso, pets} }</p>

<p> postman -> get./pets/ </p>

<h2>Resgatar todos os pets do usuário logado</h2>

<p>pr -> get('/mypets', verifyToken, pc.getAllUserPets) </p>

<p> pc.getAllUserPets(r,r){ const token ; const user = getUserByToken ; const pets = Pet.find({'user_id':user_id}).sort('-createdAt') ; json({msg: sucesso, pets}) } </p>

<p>postman</p>